<html>
<head>
    
<script src="/socket.io/socket.io.js"></script>

<script>

    // localStorage.debug='*';
    localStorage.debug='';

    var socket, poll_connection;

    var packet_count = 0;

    var mouse_tick_max = 20; //debounce: mouse must move n pixes before action

    var auto_open_img = false;


    //
    // Generic functions
    //

    function http_get(theUrl)
    {
        var xmlHttp = null;
        try {
                xmlHttp = new XMLHttpRequest();
                xmlHttp.open( "GET", theUrl, false );
                xmlHttp.send( null );
            }
        catch(err) {
            console.log(err);
            return null;
        }
        return JSON.parse(xmlHttp.responseText);
    }

    // cross browser shit
    function xinnerText(elem,newtext) {
        if (newtext) {
            if (elem && elem.innerText !== undefined)        // most browsers do this
                elem.innerText = newtext;
            else if (elem && elem.textContent !== undefined) // "standards compliant browsers"
                elem.textContent = newtext; //  (aka only firefox) do this
            }
        else {
            if (elem && elem.innerText !== undefined)
                return elem.innerText;
            else if (elem && elem.textContent !== undefined)
                return elem.textContent;
            }
    }



    //
    // PACKET LOG
    //

    // cloning nodes is faster (jsperf.com)
    var span = document.createElement('span');
    function newspan (par, text, spanclass) {
        var newspan = span.cloneNode();
        xinnerText(newspan, text);
        if (spanclass)
            newspan.className=spanclass; // hell we could probably speed things
        par.appendChild(newspan);        // up by cloning each span type.oh well
        return newspan;
    }







    var network_settings = {
        gatewayip: null,
        ip_range_start: null,
        ip_range_end: null,
        ourip: null,
        scaninterval: 30000,
        spoofinterval: 8000
    }
    var server_status = {
        scanloop_running: false,
        spoofloop_running: false
    }
    var filter_ips = []
    function network_settings_update(settings) {
        network_settings = settings
        Object.keys(network_settings).forEach(function(key){
            if (network_settings[key] && document.getElementById(key)) {
                document.getElementById(key).value = network_settings[key]
            }
        })
    }



    // wait for page to load and then find and define the container var
    var table, mouse_tick_count = 0;

    window.onload = function() {
        table       = document.getElementById('host_list');

        // if (document.getElementById('shownames').checked)
        //     show_hostnames = true;


        // update network_settings on any change to fields
        Object.keys(network_settings).forEach(function(key){
            if (document.getElementById(key)) {
                document.getElementById(key).onchange = function(e) {
                    if (typeof network_settings[key] === 'number')
                        network_settings[key] = parseFloat(e.target.value)
                    else 
                        network_settings[key] = e.target.value
                }
                document.getElementById(key).onblur = document.getElementById(key).onchange
            }
        });


        //
        // SOCKET
        //

        socket = io.connect('');

        socket.on('connect', function () {
            var infobar = document.getElementById('infobar');
            infobar.className='connected';
        });

        var poll_connection = setInterval(function(){
            if (!socket.connected) {
                var infobar = document.getElementById('infobar');
                infobar.className='disconnected';
            }
        }, 1000);

        socket.on('found_hosts', data => {
            console.log('found_hosts', data)
            var hosts = []
            Object.keys(data).forEach(function(mac){
                hosts.push({    mac : mac, 
                                ip  : data[mac],
                                name: null,
                                spoof_enabled : true,
                                is_recent     : false,
                            })
            })
            updateHosts(hosts)
        });
        socket.on('recent_hosts', data => {
            console.log('recent_hosts',data)
            var hosts = []
            Object.keys(data).forEach(function(mac){
                // if host exists in table and user has expressly set it to disable
                // then add it to a the filter_ips list and update the server
                hosts.push({    mac : mac, 
                                ip  : data[mac],
                                name: null,
                                spoof_enabled : true,
                                is_recent     : true,
                            })
            })
            updateHosts(hosts)

        });
        socket.on('filter_ips', data => console.log('filter_ips',data));

        socket.on('network_settings', data => {
            console.log('network_settings',data)
            network_settings_update(data);
        });
        socket.on('status', function(stat) {
            // console.log('status',stat,typeof stat);
            server_status = stat
            Object.keys(stat).forEach(function(key) {
                var elem = document.getElementById(key)
                if (elem) {
                    elem.innerHTML = stat[key]
                    elem.className = stat[key]
                }
            })
        });
        setInterval(function() { socket.emit('get_status') }, 1000)
        let names_waiting = false;
        socket.on('names', names => { // {ip:name,...}
            console.log('names', names)
            names_waiting = false;
            Object.keys(names).forEach(ip => {
                if (names[ip]) {
                    var elem = document.getElementById('name_'+ip.replace(/\./g,'_'))
                    if (elem)
                        elem.innerHTML = names[ip];
                }
            })
        })
        function get_names () {
            var ips = []
            Object.values(document.getElementsByClassName('name')).forEach(function(td,index,tds){
                console.log(td.innerHTML)
                // . is for one try, .. for two tries, ... for 3
                if (td.innerHTML=='' || td.innerHTML=='.' || td.innerHTML=='..') {
                    td.innerHTML += '.';
                    ips.push(td.parentElement.querySelector('.ip').innerHTML)
                }
            })
            if (ips.length) {
                    socket.emit('get_names',ips);
                    names_waiting = true;
            }
        }
        setInterval(function() { 
            if (server_status.scanloop_running &&
                !names_waiting) get_names() 
        }, 4000)




            // var dat = data.data;

            // packet_count += 1;
            // xinnerText(packetcount, packet_count+'/'+dat.count);

            // newRow(table,dat);

            // if (document.getElementById('autoscroll').checked)
            //     window.scrollTo(0, document.body.scrollHeight);
    }

    function get_found_hosts () {
        console.log('get_found_hosts')
        socket.emit('get_found_hosts')
    }
    function get_recent_hosts () {
        console.log('get_recent_hosts')
        socket.emit('get_recent_hosts')
    }
    function get_filter_ips () {
        console.log('get_filter_ips')
        socket.emit('get_filter_ips')
    }
    function do_scan1 () {
        let settings = network_settings
        settings.filter_ips = filter_ips
        console.log('do_scan1', settings)
        socket.emit('do_scan1', settings)
    }
    function start_scanloop () {
        let settings = network_settings
        settings.filter_ips = filter_ips
        console.log('start_scanloop', settings)
        socket.emit('start_scanloop', settings)
    }
    function stop_scanloop () {
        console.log('stop_scanloop')
        socket.emit('stop_scanloop')
    }
    function start_spoofloop () {
        let settings = network_settings
        settings.filter_ips = filter_ips
        console.log('start_spoofloop', settings)
        socket.emit('start_spoofloop', settings)
    }
    function stop_spoofloop () {
        console.log('stop_spoofloop')
        socket.emit('stop_spoofloop')
    }
    function get_status () {
        console.log('get_status')
        socket.emit('get_status')
    }
    function set_spoof_hosts () {
        console.log('set_spoof_hosts TODO')
        socket.emit('set_spoof_hosts')
    }
    function set_filter_ips () {
        console.log('set_filter_ips TODO')
        socket.emit('set_filter_ips')
    }

    // first time, qssumes clicked to have others other than keepclass hidden
    var hide_others = true;
    function toggleRowVisibility(keepclass) {
        var tr = document.getElementsByTagName('tr');

        for (var i = 0; i < tr.length; i++) {
            if (!tr[i].classList) // trying to avoid a invalid reference error with this check
                continue;
            if(tr[i].classList.contains(keepclass)) {
                tr[i].style.display ='table-row';
            }
            else  {
                if (hide_others)
                    tr[i].style.display = 'none';
                else
                    tr[i].style.display = '';
            }
        }
        hide_others = !hide_others;
    }

    // Update or create host row

    function updateHost(host) {
        // host { ip, mac, name, is_recent, spoof_enabled }
        let id = host.ip.replace(/\.|:/g,'_')
        if (document.getElementById(id)) {
            var row       = document.getElementById(id)
            var spoof     = row.cells[0];
            var ip        = row.cells[1];
            var mac       = row.cells[2];
            var is_recent = row.cells[3];
            var name      = row.cells[4];
        }
        else {
            var row       = table.insertRow(-1);
            var spoof     = row.insertCell(-1);
            var ip        = row.insertCell(-1);
            var mac       = row.insertCell(-1);
            var is_recent = row.insertCell(-1);
            var name      = row.insertCell(-1);

            is_recent.className = 'is_recent';
            mac.className       = 'mac';
            ip.className        = 'ip'
            spoof.className     = 'spoof_enabled'
            name.className      = 'name'

            row.id       = id;
            spoof.id     = 'spoof_'+id
            name.id      = 'name_'+id
            is_recent.id = 'is_recent_'+id
            
            ip.innerHTML = host.ip
            mac.innerHTML = host.mac
            name.innerHTML = host.name
        }
        // if (host.is_recent)
        //     row.className += ' is_recent';
        // else
        //     row.className.replace(/is_recent */g,'').trim()

        spoof.innerHTML = host.spoof_enabled
        is_recent.innerHTML = host.is_recent

        spoof.onclick = function(e) {
            console.log('toggle spoof')
            e.target.innerHTML = "a"
        }

        is_recent.onclick = function(e) {
            console.log('toggle recent')
        }

        return row;
    }
    function updateHosts(hosts, is_recent) {
        hosts.forEach(function(host) {
            updateHost(host)
        })
    }





    //
    // CHARTS
    //
    //
    // geo location information is stored in local javascript cache and we pull
    // it on every display:


</script>
<style>
    * {  font-family: sans-serif;}
body { font-size: 10.5pt; margin: 4% 10% 10% 10% ; background-color: #dee3de;}
td, th {font-size: 9pt; }
button { font-size: 1em; padding:0.5em 1em; }
input { background-color: #fafafa }
.help, .help a {color: #777;}
#command { 
    margin: 0.8em 0; font-size: 0.9em; font-family: "AtlasTypewriterRegular", "Andale Mono", "Consolas", "Lucida Console", "Menlo", "Luxi Mono", monospace;
    margin-left: 2em; 
    text-indent: -2em 
}   
h1,h2,h3,h4 {font-family: "AtlasTypewriterRegular", "Andale Mono", "Consolas", "Lucida Console", "Menlo", "Luxi Mono", monospace;}
td {     vertical-align: top;
padding-left: 0.4em; padding-right: 0.4em; white-space: nowrap;}
/* td:nth-child(1) { text-align: right;} */
table{min-width:300;}
#host_list td,
#host_list th { 
    border: 1px solid black; 
    font-family: "AtlasTypewriterRegular", "Andale Mono", "Consolas", "Lucida Console", "Menlo", "Luxi Mono", monospace;
    }
input { font-family: monospace; font-size:8.5pt; }
#infobar {
    position: fixed;
    top: 0;
    left: 0;
    opacity: 0.8;
    padding: 0.2em;
    padding-right: 0.5em;
}
#infobar.connected, .true {
    background-color: #efe; //green means we are conencted, red not
}
#infobar.disconnected, .false {
    background-color: #fcc; //green means we are conencted, red not
}
span {
    padding-left:0.5em;
    padding-right:0.5em;
}
.device {
    color: red;
}
.name {
    /* color: grey; */
    /* font-size: 0.85em; */
}
.ip {
    font-weight: bold;
}
.ip {
    font-weight: bold;
}
.mac {
    display: none;
}

.hidden {
    visibility: none;
}
.is_recent { display: none;}
.spoof_enabled { display: none;}
</style>
</head>
<body>
<div id="infobar" class="disconnected">
    <!-- <input type=checkbox id="autoscroll" checked>autoscroll -->
    <!-- <input type=checkbox id="shownames" onclick="toggle_names()" checked> -->
    <!-- <input type=checkbox onclick="auto_open_img=!auto_open_img">autoimg -->
    <!-- <span id="packetcount">&nbsp;</span> -->
</div>
<br>
<!-- <table>
    <td> -->
        <h3>Discovered Hosts</h3>
        <table>
            <tbody id='host_list'>
                <tr><th class=spoof_enabled>MiTM</th>
                    <th class=ip>IP</th>
                    <th class=mac>Mac</th>
                    <th class=is_recent>Recent</th>
                    <th class=name>Name</th></tr>
            </tbody>
        </table>
<!-- </td>
<td> -->
    <h3>Configure Scanner</h3>
    <input type=text id=ourip> (our ip to be ignored)<br>
    <input type=text id=ourmac> (our mac)<br>
    <input type=text id=gatewayip> (gateway ip to be told)<br>
    <input type=text id=ip_range_start> (ip scan range start)<br>
    <input type=text id=ip_range_end> (ip scan range end)<br>
    <input type=text id=scaninterval> (how often in ms to scan network for new hosts)<br>
    <input type=text id=spoofinterval> (how often in ms to spoof hosts)<br>
    <br>
    <button onclick=start_scanloop()>Start</button>  
    <button onclick=stop_scanloop()>Stop</button> Host Scanner, started <span id="scanloop_running">&nbsp;</span>
    <!-- <button onclick=do_scan1()>Run Once</button><br><br> -->
    <!-- <input type=checkbox id="shownames" onclick="toggle_names()" checked>MiTM enable newly found hosts<br> -->

<br><br>

 
<button onclick=start_spoofloop()>Start</button> 
<button onclick=stop_spoofloop()>Stop</button> Arpspoof, started <span id="spoofloop_running">&nbsp;</span>

<!-- </td></table> -->
</body>
</html>
